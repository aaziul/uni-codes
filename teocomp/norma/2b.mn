// swapmax => maior número fica na primeira posição do par ordenado
// (y,x) => se x < y | (x,y) => se x > y)


// clear => REG := 0
operation clear(A){
    1: if zero A then goto 0 else goto 2
    2: do dec A goto 1
}

// soma => A := A + B (soma destrutiva)
operation soma(A,B){
    1: if zero B then goto 0 else goto 2
    2: do dec B goto 3
    3: do inc A goto 1
}

operation somaNdestrutiva(A,B,C){
    1: if zero B then goto 5 else goto 2
    2: do dec B goto 3
    3: do inc A goto 4
    4: do inc C goto 1
    5: if zero C then goto 0 else goto 6
    6: do dec C goto 7
    7: do inc B goto 5
}

// load => A := B
operation load(A,B,C){
    1: do clear(A) goto 2
    2: do somaNdestrutiva(A,B,C) goto 0
}

// A := B, preservando B (atribuição destrutiva)
operation loadDestrutivo(A,B){
    1: do clear(A) goto 2
    2: do soma(A,B) goto 0
}


// A := A div 2, usando C (divide A por 2)
operation div2(A,C){
    1: do load(C,A) goto 2
    2: if zero C then goto 0 else goto 3
    3: do dec C goto 4
    4: if zero C then goto 0 else goto 5
    5: do dec C goto 6
    6: do inc A goto 2
}

// A divisivel por 2, usando C (teste se multiplo de 2)
test divBy2(A,C){
    1: do load(C,A) goto 2
    2: if zero C then goto true else goto 3
    3: do dec C goto 4
    4: do inc A goto 5
    5: if zero C then goto false else goto 6
    6: do inc A goto 7
    7: do dec C goto 2
}

// A := fst(B) usando C,D (extrai o primero componente do par)
operation fst(A,B,C,D){
    1: do clear(A) goto 2
    2: do load(C,B,D) goto 3
    3: if divBy2(C,D) then goto 4 else goto 6
    4: do div2(C,D) goto 5
    5: do inc A goto 3
    6: do clear(C) goto 0
}

// A := A div 3 usando C (divisão inteira por 3)
operation div3(A,C){
    1: do load(C,A) goto 2
    2: if zero C then goto 0 else goto 3
    3: do dec C goto 4
    4: if zero C then goto 0 else goto 5
    5: do dec C goto 6
    6: if zero C then goto 0 else goto 7
    7: do dec C goto 8
    8: do inc A goto 2
}

// A divisivel por 3 usando C (teste se múltiplo de 3)
test divBy3(A,C){
    1: do load(C,A) goto 2
    2: if zero C then goto true else goto 3
    3: do dec C goto 4
    4: do inc A goto 5
    5: if zero C then goto false else goto 6
    6: do inc A goto 7
    7: do dec C goto 8
    8: if zero C then goto false else goto 9
    9: do dec C goto 10
    10: do inc A goto 2
}

// A := snd(B) usando C,D (extrai o segundo componente do par)
operation snd(A,B,C,D){
    1: do clear(A) goto 2
    2: do load(C,B,D) goto 3
    3: if divBy3(C,D) then goto 4 else goto 6
    4: do div3(C,D) goto 5
    5: do inc A goto 3
    6: do clear(C) goto 0
}

// multiplicacao por 3
operation multTres(A, B, C){
    1: do load(B, A, C) goto 2
    2: do soma(A, B) goto 3
    3: do soma(A, B) goto 0
}

// multiplicacao por 2
operation multDois(A){
    1: do loadDestrutivo(B, A) goto 2
    2: do soma(A, B) goto 0
}

// dois elevado a algo
operation doisElevado(A,B){
    1: if zero B then goto 2 else goto 3
    2: do inc A goto 0
    3: do inc A goto 4
    4: do inc A goto 5
    5: if cmp B 1 then goto 0 else goto 6
    6: do dec B goto 7
    7: do multDois(A) goto 8
    8: do dec B goto 9
    9: if zero B then goto 0 else goto 7
}

// tres elevado a algo
operation tresElevado(A, B, C, D){
    1: if zero A then goto 2 else goto 3
    2: do inc B goto 0
    3: do inc B goto 4
    4: do inc B goto 5
    5: do inc B goto 6
    6: if cmp A 1 then goto 0 else goto 7
    7: do dec A goto 8
    8: do multTres(B, C, D) goto 9
    9: do dec A goto 9
    10: if zero A then goto 0 else goto 8
}

operation mul(A, B, C, D){
    1: do loadDestrutivo(D, A) goto 2
    2: if zero B then goto 0 else goto 3
    3: do somaNdestrutiva(A, D, C) goto 4
    4: do dec B goto 2
}

//codificacao 
operation cod(A,B,C,D,E,F){
    1: do clear(E) goto 2
    2: do clear(F) goto 3
    3: do doisElevado(A,C,E,F) goto 4
    4: do tresElevado(B,D,E,F) goto 5
    5: do mul(C, D, E, F) goto 6
    6: do loadDestrutivo(A, Y) goto 0
}

// testa se A e B contém ambos o valor zero
test ambosZero(A,B) {
    1: if zero A then goto 2 else goto false
    2: if zero B then goto true else goto false
}

// testa se a é maior que b
test aMaiorQueB(A,B){
    1: do loadDestrutivo(A,C)goto 2
    2: do loadDestrutivo(B,D) goto 3
    3: if ambosZero(C,D) then goto false else goto 4
    4: if zero C then goto false else goto 5
    5: if zero D then goto true else goto 6
    6: do dec C goto 7
    7: do dec D goto 4
}

// swapmax => maior número fica na primeira posição do par ordenado, retorna o registrador Y com o calculo da operação
operation swapmax(A,B){
    1: do clear(C) goto 2
    2: do clear(D) goto 3
    3: if aMaiorQueB(A,B) then goto 4 else goto 8
    4: do clear(E) goto 5
    5: do clear(F) goto 6
    6: do loadDestrutivo(C,A) goto 7
    7: do loadDestrutivo(D,B) goto 10
    8: do loadDestrutivo(D,A) goto 9
    9: do loadDestrutivo(C,B) goto 10
    10: do cod(A,B,C,D,E,F) goto 0
}

main{
	// extrai o primeiro componente do par
    1: do fst(A,X,C,D) goto 2
    // extrai o segundo componente do par
    2: do snd(B,X,C,D) goto 3

	3: do swapmax(A,B) goto 0
}